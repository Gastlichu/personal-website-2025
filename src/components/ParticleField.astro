---
/**
 * ParticleField - Floating luminescent particles with cursor interaction
 * Part of the Cosmic Ocean interactive background system
 * Includes directional drift during room transitions
 */
---

<canvas id="particle-field" class="fixed inset-0 pointer-events-none z-0" style="will-change: contents;" aria-hidden="true" transition:persist="particles"></canvas>

<script is:inline>
  // Prevent re-initialization if already running
  if (!window.__particleFieldInitialized) {
    window.__particleFieldInitialized = true;

    const canvas = document.getElementById('particle-field');
    const ctx = canvas.getContext('2d', { alpha: true });

    // Check for reduced motion preference
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

    // Particle colors from design system (pre-computed RGB strings for performance)
    const colors = {
      ember: '212,165,116',
      spark: '240,208,144',
      flare: '255,244,224',
      stardust: '248,176,216',
      bloom: '208,120,200',
    };

    const colorKeys = Object.keys(colors);

    // Pre-computed glow layer multipliers (radius multiplier, alpha multiplier)
    const GLOW_LAYERS = [
      [4, 0.1],
      [2.5, 0.2],
      [1.5, 0.4],
      [1, 1],
    ];
    const TWO_PI = Math.PI * 2;

    // Constellation positions (as percentages, matching ConstellationNav)
    const roomPositions = {
      '/': { x: 50, y: 22 },
      '/games': { x: 15, y: 28 },
      '/style-guide': { x: 85, y: 28 },
      '/blog': { x: 24, y: 42 },
      '/gallery': { x: 76, y: 42 },
      '/links': { x: 50, y: 52 },
      '/webcomic': { x: 32, y: 62 },
      '/photos': { x: 68, y: 62 },
      '/about': { x: 50, y: 78 },
    };

    let particles = [];
    let mouseX = -1000;
    let mouseY = -1000;
    let isMouseActive = false;
    let mouseDecayTimer = 0;
    const MOUSE_DECAY_TIME = 2000;
    const INTERACTION_RADIUS = 180;

    // Transition drift state
    let transitionDrift = { x: 0, y: 0 };
    let transitionDriftDecay = 0;
    const TRANSITION_DRIFT_STRENGTH = 3;
    const TRANSITION_DRIFT_DURATION = 800;

    function getParticleCount() {
      if (prefersReducedMotion) return 20;
      const isMobile = window.innerWidth < 768;
      return isMobile ? 40 : 80;
    }

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    function createParticle() {
      const colorKey = colorKeys[Math.floor(Math.random() * colorKeys.length)];
      const crossTime = 60 + Math.random() * 60;
      const baseSpeed = canvas.width / (crossTime * 60);

      return {
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        size: 1 + Math.random() * 3,
        color: colorKey,
        baseSpeed,
        angle: Math.random() * Math.PI * 2,
        opacity: 0.3 + Math.random() * 0.7,
        twinkleSpeed: 0.5 + Math.random() * 1.5,
        twinkleOffset: Math.random() * Math.PI * 2,
        vx: 0,
        vy: 0,
      };
    }

    function initParticles() {
      particles = [];
      const count = getParticleCount();
      for (let i = 0; i < count; i++) {
        particles.push(createParticle());
      }
    }

    function drawParticle(p, time) {
      const rgb = colors[p.color];
      const twinkle = Math.sin(time * 0.001 * p.twinkleSpeed + p.twinkleOffset);
      const currentOpacity = p.opacity * (0.5 + twinkle * 0.5);
      const currentSize = p.size * (0.8 + twinkle * 0.2);

      // Draw glow layers using pre-computed multipliers
      for (let i = 0; i < 4; i++) {
        const layer = GLOW_LAYERS[i];
        ctx.beginPath();
        ctx.arc(p.x, p.y, currentSize * layer[0], 0, TWO_PI);
        ctx.fillStyle = 'rgba(' + rgb + ',' + (currentOpacity * layer[1]) + ')';
        ctx.fill();
      }
    }

    function updateParticle(p, deltaTime) {
      if (prefersReducedMotion) return;

      const dt = deltaTime / 16.67;
      const driftX = Math.cos(p.angle) * p.baseSpeed * dt;
      const driftY = Math.sin(p.angle) * p.baseSpeed * dt;

      if (isMouseActive) {
        const dx = p.x - mouseX;
        const dy = p.y - mouseY;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < INTERACTION_RADIUS && distance > 0) {
          const force = (1 - distance / INTERACTION_RADIUS) * 0.5;
          const normalX = dx / distance;
          const normalY = dy / distance;
          p.vx += normalX * force * dt;
          p.vy += normalY * force * dt;
        }
      }

      // Apply transition drift (room-to-room navigation)
      if (transitionDriftDecay > 0) {
        const driftFactor = transitionDriftDecay / TRANSITION_DRIFT_DURATION;
        p.vx += transitionDrift.x * driftFactor * dt * 0.1;
        p.vy += transitionDrift.y * driftFactor * dt * 0.1;
      }

      p.x += driftX + p.vx;
      p.y += driftY + p.vy;
      p.vx *= 0.98;
      p.vy *= 0.98;
      p.angle += (Math.random() - 0.5) * 0.01 * dt;

      if (p.x < -20) p.x = canvas.width + 20;
      if (p.x > canvas.width + 20) p.x = -20;
      if (p.y < -20) p.y = canvas.height + 20;
      if (p.y > canvas.height + 20) p.y = -20;
    }

    let lastTime = 0;
    const MAX_DELTA = 50; // Cap deltaTime to prevent jumps after main thread blocks

    function animate(time) {
      let deltaTime = lastTime ? time - lastTime : 16.67;
      lastTime = time;

      // Clamp deltaTime to prevent particle jumps when main thread is blocked (clicks, navigation)
      if (deltaTime > MAX_DELTA) {
        deltaTime = MAX_DELTA;
      }

      if (isMouseActive && mouseDecayTimer > 0) {
        mouseDecayTimer -= deltaTime;
        if (mouseDecayTimer <= 0) {
          isMouseActive = false;
        }
      }

      // Decay transition drift
      if (transitionDriftDecay > 0) {
        transitionDriftDecay -= deltaTime;
        if (transitionDriftDecay < 0) transitionDriftDecay = 0;
      }

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (const particle of particles) {
        updateParticle(particle, deltaTime);
        drawParticle(particle, time);
      }

      requestAnimationFrame(animate);
    }

    function handleMouseMove(e) {
      mouseX = e.clientX;
      mouseY = e.clientY;
      isMouseActive = true;
      mouseDecayTimer = MOUSE_DECAY_TIME;
    }

    function handleTouchMove(e) {
      if (e.touches.length > 0) {
        mouseX = e.touches[0].clientX;
        mouseY = e.touches[0].clientY;
        isMouseActive = true;
        mouseDecayTimer = MOUSE_DECAY_TIME;
      }
    }

    function handleMouseLeave() {
      mouseDecayTimer = MOUSE_DECAY_TIME;
    }

    resizeCanvas();
    initParticles();

    window.addEventListener('resize', () => {
      resizeCanvas();
      initParticles();
    });

    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('touchmove', handleTouchMove, { passive: true });
    document.addEventListener('mouseleave', handleMouseLeave);

    // Handle room transitions - trigger directional particle drift
    function triggerTransitionDrift(fromPath, toPath) {
      if (prefersReducedMotion) return;

      // Normalize paths (handle trailing slashes and sub-pages)
      const normalizeRoom = (path) => {
        // Extract base room from path (e.g., /blog/some-post -> /blog)
        const segments = path.split('/').filter(Boolean);
        if (segments.length === 0) return '/';
        const baseRoom = '/' + segments[0];
        return roomPositions[baseRoom] ? baseRoom : path;
      };

      const fromRoom = normalizeRoom(fromPath);
      const toRoom = normalizeRoom(toPath);

      const fromPos = roomPositions[fromRoom];
      const toPos = roomPositions[toRoom];

      if (!fromPos || !toPos || fromRoom === toRoom) return;

      // Calculate direction vector (opposite to travel direction for parallax effect)
      const dx = fromPos.x - toPos.x;
      const dy = fromPos.y - toPos.y;
      const length = Math.sqrt(dx * dx + dy * dy);

      if (length > 0) {
        // Normalize and apply strength (particles drift opposite to travel, like stars passing by)
        transitionDrift.x = (dx / length) * TRANSITION_DRIFT_STRENGTH;
        transitionDrift.y = (dy / length) * TRANSITION_DRIFT_STRENGTH;
        transitionDriftDecay = TRANSITION_DRIFT_DURATION;
      }
    }

    // Listen for View Transitions navigation
    document.addEventListener('astro:before-swap', (e) => {
      const fromPath = window.location.pathname;
      const toPath = new URL(e.to).pathname;
      triggerTransitionDrift(fromPath, toPath);
    });

    requestAnimationFrame(animate);
  }
</script>
