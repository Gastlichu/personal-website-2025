---
/**
 * ParticleField - Floating luminescent particles with cursor interaction
 * Part of the Cosmic Ocean interactive background system
 * Includes directional drift during room transitions
 */
---

<canvas id="particle-field" class="fixed inset-0 pointer-events-none z-0 transition-opacity duration-200" style="will-change: contents;" aria-hidden="true" transition:persist="particles"></canvas>

<script is:inline>
  // Prevent re-initialization if already running
  if (!window.__particleFieldInitialized) {
    window.__particleFieldInitialized = true;

    const canvas = document.getElementById('particle-field');
    const ctx = canvas.getContext('2d', { alpha: true });

    // Check for reduced motion preference
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

    // Theme-specific particle colors (pre-computed RGB strings for performance)
    const themeColors = {
      cosmic: {
        ember: '212,165,116',
        spark: '240,208,144',
        flare: '255,244,224',
        stardust: '248,176,216',
        bloom: '208,120,200',
      },
      twilight: {
        lavender: '200,168,200',
        dustyrose: '216,176,184',
        pearl: '240,224,232',
        mist: '224,200,224',
        blush: '232,192,200',
      }
    };

    // Current theme state
    let currentTheme = document.documentElement.getAttribute('data-theme') === 'twilight' ? 'twilight' : 'cosmic';
    let colors = themeColors[currentTheme];
    let colorKeys = Object.keys(colors);

    // Pre-computed glow layer multipliers (radius multiplier, alpha multiplier)
    const GLOW_LAYERS = [
      [3, 0.1],
      [1.8, 0.25],
      [1, 1],
    ];
    const TWO_PI = Math.PI * 2;

    // Constellation positions (as percentages, matching Navigation)
    const roomPositions = {
      '/': { x: 50, y: 22 },
      '/games': { x: 15, y: 28 },
      '/blog': { x: 24, y: 42 },
      '/gallery': { x: 76, y: 42 },
      '/links': { x: 50, y: 52 },
      '/webcomic': { x: 32, y: 62 },
      '/photos': { x: 68, y: 62 },
      '/about': { x: 50, y: 78 },
    };

    let particles = [];
    let mouseX = -1000;
    let mouseY = -1000;
    let isMouseActive = false;
    let mouseDecayTimer = 0;
    const MOUSE_DECAY_TIME = 2000;
    const INTERACTION_RADIUS = 180;

    // Transition drift state
    let transitionDrift = { x: 0, y: 0 };
    let transitionDriftDecay = 0;
    const TRANSITION_DRIFT_STRENGTH = 2.5;
    const TRANSITION_DRIFT_DURATION = 400;

    function getParticleCount() {
      if (prefersReducedMotion) return 15;
      const isMobile = window.innerWidth < 768;
      return isMobile ? 30 : 65;
    }

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    function createParticle() {
      const colorKey = colorKeys[Math.floor(Math.random() * colorKeys.length)];
      const crossTime = 60 + Math.random() * 60;
      const baseSpeed = canvas.width / (crossTime * 60);

      return {
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        size: 1 + Math.random() * 3,
        color: colorKey,
        baseSpeed,
        angle: Math.random() * Math.PI * 2,
        opacity: 0.3 + Math.random() * 0.7,
        twinkleSpeed: 0.5 + Math.random() * 1.5,
        twinkleOffset: Math.random() * Math.PI * 2,
        vx: 0,
        vy: 0,
      };
    }

    function initParticles() {
      particles = [];
      const count = getParticleCount();
      for (let i = 0; i < count; i++) {
        particles.push(createParticle());
      }
    }

    function drawParticle(p, time) {
      const rgb = colors[p.color];
      const twinkle = Math.sin(time * 0.001 * p.twinkleSpeed + p.twinkleOffset);
      const currentOpacity = p.opacity * (0.5 + twinkle * 0.5);
      const currentSize = p.size * (0.8 + twinkle * 0.2);

      // Draw glow layers using pre-computed multipliers (2 layers for performance)
      for (let i = 0; i < GLOW_LAYERS.length; i++) {
        const layer = GLOW_LAYERS[i];
        ctx.beginPath();
        ctx.arc(p.x, p.y, currentSize * layer[0], 0, TWO_PI);
        ctx.fillStyle = 'rgba(' + rgb + ',' + (currentOpacity * layer[1]) + ')';
        ctx.fill();
      }
    }

    function updateParticle(p, deltaTime) {
      if (prefersReducedMotion) return;

      const dt = deltaTime / 16.67;
      const driftX = Math.cos(p.angle) * p.baseSpeed * dt;
      const driftY = Math.sin(p.angle) * p.baseSpeed * dt;

      if (isMouseActive) {
        const dx = p.x - mouseX;
        const dy = p.y - mouseY;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < INTERACTION_RADIUS && distance > 0) {
          const force = (1 - distance / INTERACTION_RADIUS) * 0.5;
          const normalX = dx / distance;
          const normalY = dy / distance;
          p.vx += normalX * force * dt;
          p.vy += normalY * force * dt;
        }
      }

      // Apply transition drift (room-to-room navigation)
      if (transitionDriftDecay > 0) {
        const driftFactor = transitionDriftDecay / TRANSITION_DRIFT_DURATION;
        p.vx += transitionDrift.x * driftFactor * dt * 0.1;
        p.vy += transitionDrift.y * driftFactor * dt * 0.1;
      }

      p.x += driftX + p.vx;
      p.y += driftY + p.vy;
      p.vx *= 0.98;
      p.vy *= 0.98;
      p.angle += (Math.random() - 0.5) * 0.01 * dt;

      if (p.x < -20) p.x = canvas.width + 20;
      if (p.x > canvas.width + 20) p.x = -20;
      if (p.y < -20) p.y = canvas.height + 20;
      if (p.y > canvas.height + 20) p.y = -20;
    }

    let lastTime = 0;
    const MAX_DELTA = 50; // Cap deltaTime to prevent jumps after main thread blocks

    function animate(time) {
      let deltaTime = lastTime ? time - lastTime : 16.67;
      lastTime = time;

      // Clamp deltaTime to prevent particle jumps when main thread is blocked (clicks, navigation)
      if (deltaTime > MAX_DELTA) {
        deltaTime = MAX_DELTA;
      }

      if (isMouseActive && mouseDecayTimer > 0) {
        mouseDecayTimer -= deltaTime;
        if (mouseDecayTimer <= 0) {
          isMouseActive = false;
        }
      }

      // Decay transition drift
      if (transitionDriftDecay > 0) {
        transitionDriftDecay -= deltaTime;
        if (transitionDriftDecay < 0) transitionDriftDecay = 0;
      }

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (const particle of particles) {
        updateParticle(particle, deltaTime);
        drawParticle(particle, time);
      }

      requestAnimationFrame(animate);
    }

    function handleMouseMove(e) {
      mouseX = e.clientX;
      mouseY = e.clientY;
      isMouseActive = true;
      mouseDecayTimer = MOUSE_DECAY_TIME;
    }

    function handleTouchMove(e) {
      if (e.touches.length > 0) {
        mouseX = e.touches[0].clientX;
        mouseY = e.touches[0].clientY;
        isMouseActive = true;
        mouseDecayTimer = MOUSE_DECAY_TIME;
      }
    }

    function handleMouseLeave() {
      mouseDecayTimer = MOUSE_DECAY_TIME;
    }

    // Track width to avoid iOS address bar resize triggering particle reset
    let lastWidth = window.innerWidth;

    resizeCanvas();
    initParticles();

    window.addEventListener('resize', () => {
      const newWidth = window.innerWidth;
      resizeCanvas();

      // Only reinitialize particles on actual width change (orientation/window resize)
      // iOS address bar show/hide only changes height, not width
      if (newWidth !== lastWidth) {
        lastWidth = newWidth;
        initParticles();
      }
    });

    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('touchmove', handleTouchMove, { passive: true });
    document.addEventListener('mouseleave', handleMouseLeave);

    // Handle room transitions - trigger directional particle drift
    function triggerTransitionDrift(fromPath, toPath) {
      if (prefersReducedMotion) return;

      // Normalize paths (handle trailing slashes and sub-pages)
      const normalizeRoom = (path) => {
        // Extract base room from path (e.g., /blog/some-post -> /blog)
        const segments = path.split('/').filter(Boolean);
        if (segments.length === 0) return '/';
        const baseRoom = '/' + segments[0];
        return roomPositions[baseRoom] ? baseRoom : path;
      };

      const fromRoom = normalizeRoom(fromPath);
      const toRoom = normalizeRoom(toPath);

      const fromPos = roomPositions[fromRoom];
      const toPos = roomPositions[toRoom];

      if (!fromPos || !toPos || fromRoom === toRoom) return;

      // Calculate direction vector (opposite to travel direction for parallax effect)
      const dx = fromPos.x - toPos.x;
      const dy = fromPos.y - toPos.y;
      const length = Math.sqrt(dx * dx + dy * dy);

      if (length > 0) {
        // Normalize and apply strength (particles drift opposite to travel, like stars passing by)
        transitionDrift.x = (dx / length) * TRANSITION_DRIFT_STRENGTH;
        transitionDrift.y = (dy / length) * TRANSITION_DRIFT_STRENGTH;
        transitionDriftDecay = TRANSITION_DRIFT_DURATION;
      }
    }

    // Listen for View Transitions navigation
    document.addEventListener('astro:before-swap', (e) => {
      const fromPath = window.location.pathname;
      const toPath = new URL(e.to).pathname;
      triggerTransitionDrift(fromPath, toPath);
    });

    // Fade particles during transitions for performance
    // Reduces render load while keeping animation loop running
    document.addEventListener('astro:before-preparation', () => {
      canvas.style.opacity = '0';
    });

    document.addEventListener('astro:after-swap', () => {
      canvas.style.opacity = '1';
    });

    // Also restore on page load (initial load and fallback)
    document.addEventListener('astro:page-load', () => {
      canvas.style.opacity = '1';
    });

    // Listen for theme changes and update particle colors
    window.addEventListener('themechange', (e) => {
      currentTheme = e.detail.theme;
      colors = themeColors[currentTheme];
      colorKeys = Object.keys(colors);

      // Update existing particles to use new color palette
      for (const particle of particles) {
        particle.color = colorKeys[Math.floor(Math.random() * colorKeys.length)];
      }
    });

    requestAnimationFrame(animate);
  }
</script>
